1. Это механизм, который определяет, как события (например, щелчки мыши, нажатия клавиш) распространяются по дереву DOM в браузере. Он включает в себя три основные фазы:
- Фаза захвата:
Событие начинается с корневого элемента DOM и проходит вниз к целевому элементу, на который произошло событие.
Например, если у вас есть <body>, <div>, и <button>, событие сначала будет обрабатываться на <body>, затем на <div>, и только потом на <button>.
- Фаза целевого события:
На этой стадии событие обрабатывается непосредственно на целевом элементе, на который оно было инициировано.
Например, если пользователь нажимает на кнопку, событие обрабатывается именно на этом элементе.
- Фаза всплытия:
Событие движется вверх от целевого элемента к корневому элементу.
Сначала оно обрабатывается на целевом элементе, затем на его родителе, и так далее, пока не достигнет корня.

Использование метода addEventListener с параметром capture, чтобы установить обработчик события на фазе захвата.
Предотвращение всплытия событий с помощью event.stopPropagation(), чтобы избежать ненужного выполнения обработчиков на родительских элементах.
Разработка сложных интерфейсов, где поведение элементов зависит от того, как события распространяются по дереву DOM.

2. Это объект, который представляет результат асинхронной операции. Он позволяет обработать успешный результат или ошибку, произошедшую во время выполнения этой операции.

Основные состояния:

- Pending (Ожидание): начальное состояние, обещание не выполнено и не отклонено.
- Fulfilled (Исполнено): операция успешно завершена, и Promise имеет результат.
- Rejected (Отклонено): операция завершилась с ошибкой, и Promise имеет причину отказа.

Создается новый Promise с функцией, принимающей два аргумента: resolve и reject.
Внутри этой функции происходит асинхронная операция. Если она успешна, вызывается resolve(result), а если произошла ошибка — reject(error).

Событийный цикл управляет выполнением асинхронного кода в JavaScript. Он проверяет очередь событий и выполняет обработчики событий в порядке их поступления, обеспечивая однопоточность.
Когда Promise завершается, его обработчики (например, .then() и .catch()) добавляются в очередь событий, и будут выполнены, когда стек вызовов будет пуст.

3. Это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные и код: данные в виде полей (атрибутов) и код в виде методов (функций).

Ключевые принципы ООП:
- Инкапсуляция:
Скрытие внутреннего состояния объекта и предоставление доступа только через методы.
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    getInfo() {
        return `${this.name} is ${this.age} years old.`;
    }
}
- Наследование:
Возможность создавать новые классы на основе существующих, что позволяет повторно использовать код.
class Employee extends Person {
    constructor(name, age, position) {
        super(name, age);
        this.position = position;
    }

    getInfo() {
        return `${super.getInfo()} They work as a ${this.position}.`;
    }
}
- Полиморфизм:
Способность объектов разных классов обрабатывать один и тот же метод по-разному.
class Dog {
    speak() {
        return "Woof!";
    }
}

class Cat {
    speak() {
        return "Meow!";
    }
}

const animals = [new Dog(), new Cat()];
animals.forEach(animal => console.log(animal.speak()));
-Абстракция:
Упрощение сложных систем путем выделения их основных характеристик и поведения.
class Animal {
    speak() {
        throw new Error("Метод speak должен быть реализован в подклассе.");
    }
}

class Bird extends Animal {
    speak() {
        return "Chirp!";
    }
}

В JavaScript ООП реализовано через прототипы, классы и методы.
Классы были введены в ES6, но до этого использовались функции-конструкторы и прототипы.

4.
Ввод URL:
Пользователь вводит URL в адресной строке браузера.

Разрешение DNS:
Браузер отправляет DNS-запрос для преобразования доменного имени в IP-адрес.

Установление соединения:
Браузер устанавливает TCP-соединение с сервером по IP-адресу.

Отправка HTTP-запроса:
Браузер отправляет HTTP-запрос на сервер, чтобы получить запрашиваемый ресурс.

Обработка запроса сервером:
Сервер обрабатывает запрос и возвращает HTTP-ответ, содержащий запрашиваемые данные (например, HTML-страницу).

Получение ответа:
Браузер получает HTTP-ответ от сервера, который содержит статус-код и данные (HTML, CSS, JavaScript и т.д.).

Отображение страницы:
Браузер разбирает HTML, загружает внешние ресурсы (CSS, JS, изображения) и отображает страницу для пользователя.

Технологии, позволяющие ускорить процесс:
- Кэширование: браузеры могут кэшировать ресурсы, чтобы не загружать их повторно при следующем запросе.
- CDN (Content Delivery Network): географически распределенные серверы, которые обеспечивают более быстрый доступ к контенту.
- HTTP/2: улучшенная версия HTTP, которая позволяет мультиплексировать потоки и уменьшать задержки.

Проблемы, которые могут возникать:
- Безопасность:
Уязвимости, такие как XSS (межсайтовый скриптинг) и CSRF (межсайтовая подделка запросов).
Использование HTTPS для защиты данных при передаче.
-Междоменное взаимодействие (CORS):
Ограничения, связанные с безопасностью, которые не позволяют веб-приложениям делать запросы на другой домен без соответствующих заголовков.
Необходимость настроить CORS на сервере для разрешения запросов из других источников.
